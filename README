############################### Command Usage ##################################
Attention: 1. <fileName*>  : a string literal without file extension (e.g., .blif .vmt)
           2. <cFileName*> : a string literal without file extension (e.g., .blif .vmt)
           3. <sFileName*> : a string literal without file extension (e.g., .blif .vmt)
           4. <index>      : non-negative integer
           5. L(*) indicates the language recognized by the automaton describing by *
           6. replace, indexof, notcontains, notprefixof_smt and notsuffixof_smt are supported
              under the assumption that the complemented automaton is known 
              due to the incapability of constructing complement of language

usage: trklen            <fileName> <index>
                         add an integer variable to track the length of an automaton
       fileName        : the name of the file describing an automaton
       integer         : the index of the integer variable

usage: intersect         <fileName_1> <fileName_2>
                         construct the intersection of two automata
       fileName        : the name of the file describing an automaton

usage: concate           <fileName_1> <fileName_2>
                         construct the concatenation of two automata
       fileName        : the name of the file describing an automaton

usage: replace           <fileName_1> <fileName_2> <fileName_3> <cFileName>
                         language-to-language replace corresponding to Rep(A1,A2,A3) in paper
       fileName        : the name of the file describing an automaton
       cFileName       : the name of the file describing a complmented automaton

usage: contains          <fileName_1> <fileName_2>
                         construct the intersection of L(fileName_1) and .*L(fileName_2).*
       fileName        : the name of the file describing an automaton

usage: notcontains       <fileName> <cFileName>
                         construct the intersection of L(fileName) and L(cFileName)
       fileName        : the name of the file describing an automaton
       cFileName       : the name of the file describing a complemented automaton

usage: trkidx            <fileName> <sFileName> <cFileName> <index_1> <index_2>
                         construct an automaton that accept the intersection of L(fileName) and .*L(sFileName).* with index_1 indicating the not-less-than position of L(sFileName) and index_2 indicating the first occurence position of L(sFileName) (first occurence after index_1 position)
       fileName        : the name of the file describing an automaton
       sFileName       : the name of the file describing an automaton recognizing a string literal
       cFileName       : the name of the file describing a complemented automaton
       index_1         : the index of the integer variable indicating the not-less-than position (WARNING)
       index_2         : the index of the integer variable indicating the answer position

usage: substr            <fileName> <index_1> <index_2>
                         construct the automaton recognizing the set of substrings with starting position and pass-the-end position specified by index_1 and index_2 resp.
       fileName        : the name of the file describing an automaton
       index_1         : the index of the integer variable indicating the beginning position
       index_2         : the index of the integer variable indicating the pass-the-end position (WARNING)

usage: prefixof_smt      <fileName_1> <fileName_2>
                         construct the intersection of L(fileName_1).* and L(fileName_2)
       fileName        : the name of the file describing an automaton

usage: suffixof_smt      <fileName_1> <fileName_2>
                         construct the intersection of .*L(fileName_1) and L(fileName_2)
       fileName        : the name of the file describing an automaton

usage: notprefixof_smt   <cFileName> <fileName>
                         construct the intersection of L(cFileName) and L(fileName)
       fileName        : the name of the file describing an automaton
       cFileName       : the name of the file describing a complemented automaton

usage: notsuffixof_smt   <cFileName> <fileName>
                         construct the intersection of L(cFileName) and L(fileName)
       fileName        : the name of the file describing an automaton
       cFileName       : the name of the file describing a complemented automaton

usage: read              <fileName>
                         read an automaton
       fileName        : the name of the file describing an automaton

usage: write             <fileName>
                         write the current automaton to fileName
       fileName        : the name of the file describing an automaton

usage: addpred
                         add predicates into current automaton

usage: isempty           <fileName>
                         construct the sequential circuit for ABC in BLIF format

############################### Length Automaton Description ##################################
A Length Automaton file (LAut) includes 3 sections

<leaf automaton regex>
;
<predicates>
;
<dependencies>

section : leaf automaton regex
desc    : the regular expression of each leaf automaton
format  : <leaf automaton name> <regular expression>
notice  : character not in [0-9a-zA-Z] must be escaped by a backslash if it is treated as a character

section : predicates
desc    : predicates in prefix expression with n-ary(n>1) operation embraced by parentheses
format  : operations for boolean and integer are trivial, three operations associated with legnth 
          are specified as follows:
          
          alias*   : an integer variable or a constant integer
          index*   : an non-negative integer used in LAut construction
          smt2     : described corresponding constraint in smt2 format
		  
          operation: get string length
          desc     : assert an integer variable to represents the embedded integer in a trklen operation
          smt2     : (= <alias> str.len <string variable>)
          format   : len <alias> <index>

          operation: get string indexof
          desc     : assert two integer variable to represent the integer added in trkidx, with alias_1
                     indicate the not-less-than position and alias_2 indicate the index
          smt2     : (= <alias_2> (str.indexof <string variable> <constant string> <alias_1>))
          format   : indexof <alias_1> <alias_2> <index_1> <index_2>
                     <alias_1>: the not-less-than position
                     <alias_2>: the answer position
                     <index_1>: for <alias_1>
                     <index_2>: for <alias_2>
          
          operation: string substr
          desc     : assert the substring of a string variable starts from alias_1 with offset alias_2
          smt2     : (str.substr <string variable> <alias_1> <alias_2>)
          format   : substr <alias_1> <alias_2> <index_1> <index_2>
                     <alias_1>: the start position
                     <alias_2>: the offset
                     <index_1>: for <alias_1>
                     <index_2>: for <alias_2>

section : dependencies
desc    : bottom-up construction of the sink node
format  : [commands] (a intermediate command should be followed with a "write" command)
          <addpred>
          <write sink>
          <isempty sink>
          
############################### Automaton Alphabet Encoding ##################################
using UTF-16 as alphabet
append 1 more bit to represent special alphabet
1 0000 0000 0000 0000 epsilon
1 0000 0000 0000 0001 <
1 0000 0000 0000 0002 >

blif file
input:      x0(MSB) - x16(LSB)
state:      s0 - sk
next state: n0 - nk

vmt file
input: current: x0(MSB)      - x16(LSB)
       next   : x0.next(MSB) - x16.next(LSB)
state: current: s0      - si
       next   : s0.next - si.next
lvar : current: n0      - nj
       next   : n0.next - nj.next
